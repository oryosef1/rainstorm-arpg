
// Logging System Tests
const { GameLogger } = require('../game-core/systems/logging-system');
const { LogAggregator } = require('../game-core/utils/log-aggregator');

describe('Advanced Logging System', () => {
  let logger;
  let aggregator;
  
  beforeEach(() => {
    logger = new GameLogger();
    aggregator = new LogAggregator();
  });
  
  afterEach(() => {
    logger.clearLogs();
    if (aggregator.shutdown) aggregator.shutdown();
  });
  
  describe('GameLogger', () => {
    test('should log messages with correct levels', () => {
      logger.info('Test message', { test: true });
      const logs = logger.logs;
      
      expect(logs).toHaveLength(1);
      expect(logs[0].level).toBe('INFO');
      expect(logs[0].message).toBe('Test message');
      expect(logs[0].context.test).toBe(true);
    });
    
    test('should track performance metrics', () => {
      const mockSystem = { constructor: { name: 'TestSystem' } };
      logger.logPerformance(mockSystem, 15.5, 100);
      
      const metrics = logger.performanceMetrics.get('TestSystem');
      expect(metrics).toBeDefined();
      expect(metrics.duration).toBe(15.5);
      expect(metrics.entityCount).toBe(100);
    });
    
    test('should handle error logging with stack traces', () => {
      const error = new Error('Test error');
      logger.logError(error, { component: 'test' });
      
      const errorLogs = logger.logs.filter(log => log.level === 'ERROR');
      expect(errorLogs).toHaveLength(1);
      expect(errorLogs[0].context.stack).toBeDefined();
    });
    
    test('should respect log level filtering', () => {
      logger.setLogLevel('WARN');
      
      logger.debug('Debug message');
      logger.info('Info message');
      logger.warn('Warning message');
      
      expect(logger.logs).toHaveLength(1);
      expect(logger.logs[0].level).toBe('WARN');
    });
    
    test('should generate performance reports', () => {
      const mockSystem = { constructor: { name: 'TestSystem' } };
      logger.logPerformance(mockSystem, 20, 150);
      
      const report = logger.getPerformanceReport();
      expect(report.systemMetrics.TestSystem).toBeDefined();
      expect(report.systemMetrics.TestSystem.duration).toBe(20);
    });
    
    test('should detect performance issues', () => {
      const mockSystem = { constructor: { name: 'SlowSystem' } };
      const logSpy = jest.spyOn(logger, 'critical');
      
      logger.logPerformance(mockSystem, 35, 100, { fps: 25 });
      
      expect(logSpy).toHaveBeenCalled();
    });
  });
  
  describe('LogAggregator', () => {
    test('should register and process log sources', () => {
      aggregator.registerSource('test', logger);
      
      logger.info('Test message');
      
      // Give aggregator time to process
      setTimeout(() => {
        expect(aggregator.aggregatedLogs.length).toBeGreaterThan(0);
      }, 100);
    });
    
    test('should apply filters correctly', () => {
      aggregator.addFilter('level', (log) => log.level === 'ERROR');
      
      const testLog = {
        level: 'INFO',
        message: 'Test',
        timestamp: Date.now()
      };
      
      expect(aggregator.passesFilters(testLog)).toBe(false);
      
      testLog.level = 'ERROR';
      expect(aggregator.passesFilters(testLog)).toBe(true);
    });
    
    test('should generate system health reports', () => {
      const health = aggregator.getSystemHealth();
      
      expect(health).toHaveProperty('status');
      expect(health).toHaveProperty('timestamp');
      expect(health).toHaveProperty('logVolume');
      expect(health).toHaveProperty('errorCount');
    });
  });
  
  describe('Integration Tests', () => {
    test('should integrate with ECS systems', () => {
      // Mock system with logging
      class TestSystem {
        constructor() {
          this.entities = new Set();
        }
        
        update(deltaTime) {
          const startTime = performance.now();
          
          try {
            // Simulate system work
            for (let i = 0; i < 1000; i++) {
              Math.random();
            }
          } catch (error) {
            logger.logError(error, { 
              system: this.constructor.name, 
              deltaTime 
            });
            throw error;
          } finally {
            const duration = performance.now() - startTime;
            logger.logPerformance(this, duration, this.entities.size);
          }
        }
      }
      
      // Set logger to DEBUG level to capture performance logs
      logger.setLogLevel('DEBUG');
      
      const system = new TestSystem();
      system.update(16.67);
      
      // Check for any logs generated by the system
      const allLogs = logger.logs;
      expect(allLogs.length).toBeGreaterThan(0);
      
      // Check that logs were created with the correct context
      const hasSystemContext = allLogs.some(log => 
        log.context && (log.context.duration || log.context.system)
      );
      expect(hasSystemContext).toBe(true);
    });
  });
});
